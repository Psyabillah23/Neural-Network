# -*- coding: utf-8 -*-
"""nn prak 1 & 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BTw-hhFxaKzpwqXIrZV2suqL9r0Upjou
"""

import numpy as np
import matplotlib.pyplot as plt

# Data
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
t = np.array([0, 0, 0, 1])

class Perceptron:
    def __init__(self, nin):
        rand = np.random.RandomState(1)
        self.W = rand.normal(loc=0.0, scale=0.01, size=nin)
        self.b = np.float_(0.0)  # b = w0
        print(f"Initial Weights (W): {self.W}")
        print(f"Initial Bias (b): {self.b}\n")

    def fit(self, X, y, epochs=10, eta=0.01):
        for _ in range(epochs):
            for i in range(X.shape[0]):
                z = np.dot(X[i], self.W) + self.b
                yout = np.where(z >= 0.0, 1, 0)
                if yout != y[i]:
                    delta = eta * (y[i] - yout)
                    self.W += delta * X[i]
                    self.b += delta

            print(f"Weights after training (W): {self.W}")
            print(f"Bias after training (b): {self.b}\n")

    def predict(self, x):
        z = np.dot(x, self.W) + self.b
        return np.where(z >= 0.0, 1, 0)

X = np.array([[0, 0],
              [0, 1],
              [1, 0],
              [1, 1]])
t = np.array([0, 0, 0, 1])
NN = Perceptron(X.shape[1])

print("[INFO] training perceptron...")
NN.fit(X, t, 5)

print("[INFO] testing perceptron...")
for (x, target) in zip(X, t):
    pred = NN.predict(x)
    print("[INFO] data={}, ground-truth={}, pred={}".format(x, target, pred))

# Scatter plot dengan decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Menghitung decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(NN.W[0] * x1_vals + NN.b) / NN.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary')
plt.legend(loc='best')
plt.grid(True)
plt.show()# Scatter plot dengan decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Menghitung decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(NN.W[0] * x1_vals + NN.b) / NN.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary')
plt.legend(loc='best')
plt.grid(True)
plt.show()# Scatter plot dengan decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Menghitung decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(NN.W[0] * x1_vals + NN.b) / NN.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary')
plt.legend(loc='best')
plt.grid(True)
plt.show()# Scatter plot dengan decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Menghitung decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(NN.W[0] * x1_vals + NN.b) / NN.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary')
plt.legend(loc='best')
plt.grid(True)
plt.show()# Scatter plot dengan decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Menghitung decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(NN.W[0] * x1_vals + NN.b) / NN.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary')
plt.legend(loc='best')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Data for AND logic gate
X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
t = np.array([0, 0, 0, 1])

class SimplePerceptron:
    def __init__(self, input_size):
        self.W = np.array([0.5, -0.5])
        self.b = 0.0

    def fit(self, X, y, epochs=5, learning_rate=0.1):
        for _ in range(epochs):
            for i in range(X.shape[0]):
                z = np.dot(X[i], self.W) + self.b
                y_pred = 1 if z >= 0 else 0
                if y_pred != y[i]:
                    update = learning_rate * (y[i] - y_pred)
                    self.W += update * X[i]
                    self.b += update

    def predict(self, x):
        z = np.dot(x, self.W) + self.b
        return 1 if z >= 0 else 0  # Step activation

# Create and train the perceptron
perceptron = SimplePerceptron(X.shape[1])
perceptron.fit(X, t,10)

# Test the perceptron
for (x, target) in zip(X, t):
    prediction = perceptron.predict(x)
    print(f"Input: {x}, Target: {target}, Prediction: {prediction}")

# Scatter plot with decision boundary
for i, label in enumerate(t):
    if label == 0:
        plt.scatter(X[i][0], X[i][1], color='red', label='0' if i == 0 else "")
    else:
        plt.scatter(X[i][0], X[i][1], color='blue', label='1' if i == 3 else "")

# Calculate decision boundary
x1_vals = np.array([0, 1])
x2_vals = -(perceptron.W[0] * x1_vals + perceptron.b) / perceptron.W[1]

# Plot decision boundary
plt.plot(x1_vals, x2_vals, color='green', label='Decision Boundary')

plt.xlabel('X1')
plt.ylabel('X2')
plt.title('Perceptron Decision Boundary ELKOM 2 ')
plt.legend(loc='best')
plt.grid(True)
plt.show()

